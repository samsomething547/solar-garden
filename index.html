<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Solar Garden â€“ Glitter Touch</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #050814;
      font-family: system-ui, sans-serif;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      touch-action: none; /* allow us to intercept touches */
    }
  </style>
</head>
<body>
  <canvas id="garden"></canvas>

  <script>
  const canvas = document.getElementById("garden");
  const ctx = canvas.getContext("2d");

  let width = 0;
  let height = 0;
  let dpr = window.devicePixelRatio || 1;

  function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    dpr = window.devicePixelRatio || 1;

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    createScene();
  }

  window.addEventListener("resize", resize);
  resize();

  // ----- FLOWERS & CRYSTALS -----

  const flowers = [];
  const crystals = [];

  function createScene() {
    flowers.length = 0;
    crystals.length = 0;

    const layers = [
      { depth: 0.35, count: 10 }, // far
      { depth: 0.6,  count: 12 }, // mid
      { depth: 0.9,  count: 8 }   // near
    ];

    for (const layer of layers) {
      for (let i = 0; i < layer.count; i++) {
        const spread = width * 1.1;
        const x = (Math.random() * spread) - (spread * 0.05);
        const baseY = height * (0.60 + (Math.random() - 0.5) * 0.08);
        const stemHeight = height * (0.12 + Math.random() * 0.16) * layer.depth;
        const radius = 10 + Math.random() * 18 * layer.depth;
        const type = Math.random() < 0.45 ? "bloom" : "orb";

        flowers.push({
          x,
          baseY,
          stemHeight,
          radius,
          depth: layer.depth,
          type,
          pulseOffset: Math.random() * Math.PI * 2
        });
      }
    }

    // Floating crystals (diamonds) above flowers, clustered near the central beam
    const crystalCount = 18;
    for (let i = 0; i < crystalCount; i++) {
      const cx = width * 0.5 + (Math.random() - 0.5) * width * 0.45;
      const cy = height * 0.16 + Math.random() * height * 0.35;
      crystals.push({
        x: cx,
        y: cy,
        size: 6 + Math.random() * 10,
        floatPhase: Math.random() * Math.PI * 2
      });
    }
  }

  // ----- DRAWING -----

  function drawBackground() {
    // sky
    const sky = ctx.createLinearGradient(0, 0, 0, height);
    sky.addColorStop(0, "#101827");
    sky.addColorStop(0.5, "#050816");
    sky.addColorStop(1, "#020617");
    ctx.fillStyle = sky;
    ctx.fillRect(0, 0, width, height);

    // ground
    const groundGrad = ctx.createLinearGradient(0, height * 0.55, 0, height);
    groundGrad.addColorStop(0, "#020814");
    groundGrad.addColorStop(1, "#020512");
    ctx.fillStyle = groundGrad;
    ctx.fillRect(0, height * 0.55, width, height * 0.45);

    // vertical beam (narrower, softer)
    const beamWidth = width * 0.35;
    const beamX = width * 0.5 - beamWidth / 2;
    const beamGrad = ctx.createLinearGradient(beamX, 0, beamX + beamWidth, 0);
    beamGrad.addColorStop(0, "rgba(255,255,255,0)");
    beamGrad.addColorStop(0.45, "rgba(255,248,230,0.16)");
    beamGrad.addColorStop(0.55, "rgba(255,244,214,0.30)");
    beamGrad.addColorStop(0.65, "rgba(255,248,230,0.16)");
    beamGrad.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle = beamGrad;
    ctx.fillRect(beamX, 0, beamWidth, height);
  }

  function drawFlowers(time) {
    const t = time * 0.001;

    // sort by depth so far flowers render first
    flowers.sort((a, b) => a.depth - b.depth);

    // stems
    for (const f of flowers) {
      const topY = f.baseY - f.stemHeight;
      const alpha = 0.35 + 0.45 * f.depth;
      ctx.strokeStyle = `rgba(248,248,255,${alpha})`;
      ctx.lineWidth = 1 + f.depth;
      ctx.beginPath();
      ctx.moveTo(f.x, f.baseY);
      ctx.lineTo(f.x, topY);
      ctx.stroke();
    }

    // heads
    for (const f of flowers) {
      const topY = f.baseY - f.stemHeight;
      const pulse = 0.5 + 0.3 * Math.sin(t * 1.2 + f.pulseOffset);
      const r = f.radius * (0.9 + 0.12 * pulse);
      const depthAlpha = 0.35 + 0.45 * f.depth;

      // glow halo
      const halo = ctx.createRadialGradient(f.x, topY, 0, f.x, topY, r * 3.5);
      halo.addColorStop(0, `rgba(255,247,237,${0.75 * depthAlpha})`);
      halo.addColorStop(0.5, `rgba(253,186,116,${0.35 * depthAlpha})`);
      halo.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = halo;
      ctx.beginPath();
      ctx.arc(f.x, topY, r * 3.5, 0, Math.PI * 2);
      ctx.fill();

      if (f.type === "orb") {
        // pearl orb
        const orb = ctx.createRadialGradient(
          f.x - r * 0.4, topY - r * 0.4, r * 0.2,
          f.x, topY, r
        );
        orb.addColorStop(0, "#fef3c7");
        orb.addColorStop(0.4, "#fde68a");
        orb.addColorStop(1, "#fb923c");
        ctx.fillStyle = orb;
        ctx.beginPath();
        ctx.arc(f.x, topY, r, 0, Math.PI * 2);
        ctx.fill();
      } else {
        // crystal bloom petals
        const petalCount = 6;
        const petalR = r * 1.4;
        const petalW = r * 0.85;
        const petalH = r * 0.46;

        ctx.save();
        ctx.translate(f.x, topY);
        ctx.rotate(0.12 * Math.sin(t * 0.3 + f.pulseOffset));

        for (let i = 0; i < petalCount; i++) {
          const angle = (i / petalCount) * Math.PI * 2;
          ctx.save();
          ctx.rotate(angle);

          const petalGrad = ctx.createLinearGradient(0, -petalH, 0, petalH);
          petalGrad.addColorStop(0, "rgba(255,255,255,0.85)");
          petalGrad.addColorStop(0.5, "rgba(253,230,210,0.65)");
          petalGrad.addColorStop(1, "rgba(249,115,22,0.45)");
          ctx.fillStyle = petalGrad;

          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.quadraticCurveTo(petalW, -petalH, 0, -petalR);
          ctx.quadraticCurveTo(-petalW, -petalH, 0, 0);
          ctx.closePath();
          ctx.fill();

          ctx.restore();
        }

        ctx.restore();
      }

      // teal core (for both types)
      const coreR = r * 0.35;
      const core = ctx.createRadialGradient(
        f.x, topY - coreR * 0.5, coreR * 0.1,
        f.x, topY, coreR
      );
      core.addColorStop(0, "#e0f2fe");
      core.addColorStop(1, "#0ea5e9");
      ctx.fillStyle = core;
      ctx.beginPath();
      ctx.arc(f.x, topY, coreR, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawCrystals(time) {
    const t = time * 0.001;
    ctx.save();
    ctx.globalCompositeOperation = "lighter";

    for (const c of crystals) {
      const floatY = c.y + Math.sin(t * 0.6 + c.floatPhase) * 6;
      const size = c.size;
      const alpha = 0.7;

      const grad = ctx.createLinearGradient(
        c.x, floatY - size,
        c.x, floatY + size
      );
      grad.addColorStop(0, `rgba(248,250,252,${alpha})`);
      grad.addColorStop(0.4, `rgba(255,245,235,${alpha * 0.9})`);
      grad.addColorStop(1, `rgba(96,165,250,${alpha * 0.6})`);

      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.moveTo(c.x, floatY - size);
      ctx.lineTo(c.x + size * 0.7, floatY);
      ctx.lineTo(c.x, floatY + size);
      ctx.lineTo(c.x - size * 0.7, floatY);
      ctx.closePath();
      ctx.fill();
    }

    ctx.restore();
  }

  // ----- GLITTER PARTICLES (same idea as before) -----

  const particles = [];
  const MAX_PARTICLES = 1800;

  function spawnGlitter(x, y) {
    const count = 80;
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 40 + Math.random() * 60;
      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed - 20,
        life: 1.0,
        size: 1.5 + Math.random() * 2.2
      });
    }
    if (particles.length > MAX_PARTICLES) {
      particles.splice(0, particles.length - MAX_PARTICLES);
    }
  }

  function updateParticles(dt) {
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 20 * dt;
      p.vx *= 0.98;
      p.vy *= 0.98;
      p.life -= dt * 0.9;
      if (p.life <= 0 || p.y > height + 40) {
        particles.splice(i, 1);
      }
    }
  }

  function drawParticles() {
    if (!particles.length) return;
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for (const p of particles) {
      const alpha = Math.max(0, p.life);
      const radius = p.size;
      const grad = ctx.createRadialGradient(
        p.x, p.y, 0,
        p.x, p.y, radius * 3
      );
      grad.addColorStop(0, `rgba(255,255,255,${alpha})`);
      grad.addColorStop(0.4, `rgba(253,224,171,${alpha * 0.8})`);
      grad.addColorStop(1, `rgba(56,189,248,0)`);
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(p.x, p.y,

</body>
</html>
